{"version":3,"file":"AliasManaging.js","sourceRoot":"","sources":["../../src/generators/AliasManaging.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,YAAY,CAAC;;;AAIb,IAAI,mBAAmB,GAAW,EAAE,CAAC;AAErC,SAAgB,sBAAsB,CAAC,UAAkB;IACvD,mBAAmB,GAAG,UAAU,CAAC;AACnC,CAAC;AAFD,wDAEC;AAED,SAAgB,eAAe,CAAC,QAAgB;IAC9C,OAAO,GAAG,mBAAmB,QAAQ,QAAQ,EAAE,CAAC;AAClD,CAAC;AAFD,0CAEC;AAOD,MAAM,iBAAiB,GAAG,wBAAwB,CAAC;AAKnD,SAAS,oBAAoB,CAC3B,OAAoB,EACpB,aAAqB,EACrB,QAA2B;IAE3B,QAAQ,CAAC,iBAAiB,CAAC,GAAG,aAAa,CAAC;IAC5C,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,QAAQ,CAAC;IACxC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IACjC,OAAO,aAAa,CAAC;AACvB,CAAC;AAED,SAAgB,wBAAwB,CACtC,OAAoB,EACpB,aAAqB,EACrB,UAAa;IAEb,iDAAiD;IACjD,6CAA6C;IAC7C,yBAAyB;IACzB,uFAAuF;IACvF,MAAM,QAAQ,GAAsB,UAAU,CAAC;IAC/C,MAAM,GAAG,GAAG,QAAQ,CAAC,iBAAiB,CAAC,CAAC;IACxC,IAAI,GAAG,KAAK,SAAS,EAAE;QACrB,OAAO,eAAe,CAAC,GAAG,CAAC,CAAC;KAC7B;IAED,iDAAiD;IACjD,+BAA+B;IAC/B,8DAA8D;IAC9D,IAAI,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,SAAS,EAAE;QAC9C,OAAO,eAAe,CACpB,oBAAoB,CAAI,OAAO,EAAE,aAAa,EAAE,QAAQ,CAAC,CAC1D,CAAC;KACH;IAED,qCAAqC;IACrC,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,OAAO,OAAO,CAAC,KAAK,CAAC,GAAG,aAAa,GAAG,KAAK,EAAE,CAAC,KAAK,SAAS,EAAE;QAC9D,KAAK,EAAE,CAAC;KACT;IAED,OAAO,eAAe,CACpB,oBAAoB,CAAC,OAAO,EAAE,GAAG,aAAa,GAAG,KAAK,EAAE,EAAE,QAAQ,CAAC,CACpE,CAAC;AACJ,CAAC;AAjCD,4DAiCC","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n * @format\n */\n\n'use strict';\n\nimport type {NativeModuleObjectTypeAnnotation} from '@react-native/codegen/lib/CodegenSchema';\n\nlet preferredModuleName: string = '';\n\nexport function setPreferredModuleName(moduleName: string): void {\n  preferredModuleName = moduleName;\n}\n\nexport function getAliasCppName(typeName: string): string {\n  return `${preferredModuleName}Spec_${typeName}`;\n}\n\nexport interface AliasMap<T = NativeModuleObjectTypeAnnotation> {\n  types: {[name: string]: T | undefined};\n  jobs: string[];\n}\n\nconst ExtendedObjectKey = '$RNW-TURBOMODULE-ALIAS';\ntype ExtendedObject<T> = {\n  '$RNW-TURBOMODULE-ALIAS'?: string;\n} & T;\n\nfunction recordAnonymousAlias<T = NativeModuleObjectTypeAnnotation>(\n  aliases: AliasMap<T>,\n  baseAliasName: string,\n  extended: ExtendedObject<T>,\n): string {\n  extended[ExtendedObjectKey] = baseAliasName;\n  aliases.types[baseAliasName] = extended;\n  aliases.jobs.push(baseAliasName);\n  return baseAliasName;\n}\n\nexport function getAnonymousAliasCppName<T = NativeModuleObjectTypeAnnotation>(\n  aliases: AliasMap<T>,\n  baseAliasName: string,\n  objectType: T,\n): string {\n  // someone found an anonymous object literal type\n  // if the ExtendedObjectKey flag has been set\n  // then it is a known one\n  // this happens because method signatures are generate twice in spec and error messages\n  const extended = <ExtendedObject<T>>objectType;\n  const key = extended[ExtendedObjectKey];\n  if (key !== undefined) {\n    return getAliasCppName(key);\n  }\n\n  // if the ExtendedObjectKey flag has not been set\n  // it means it is a unknown one\n  // associate the name with this object literal type and return\n  if (aliases.types[baseAliasName] === undefined) {\n    return getAliasCppName(\n      recordAnonymousAlias<T>(aliases, baseAliasName, extended),\n    );\n  }\n\n  // sometimes names could be anonymous\n  let index = 2;\n  while (aliases.types[`${baseAliasName}${index}`] !== undefined) {\n    index++;\n  }\n\n  return getAliasCppName(\n    recordAnonymousAlias(aliases, `${baseAliasName}${index}`, extended),\n  );\n}\n"]}