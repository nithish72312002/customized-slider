"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 * @format
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Telemetry = exports.NuGetPackagesWeTrack = exports.NpmPackagesWeTrack = exports.EventNamesWeTrack = exports.CodedErrorEventName = exports.CommandEventName = void 0;
const coreOneDS = __importStar(require("@microsoft/1ds-core-js"));
const _1ds_post_js_1 = require("@microsoft/1ds-post-js");
const basePropUtils = __importStar(require("./utils/basePropUtils"));
const versionUtils = __importStar(require("./utils/versionUtils"));
const errorUtils = __importStar(require("./utils/errorUtils"));
const nameUtils = __importStar(require("./utils/nameUtils"));
// 1DS instrumentation key
const RNW_1DS_INSTRUMENTATION_KEY = '49ff6d3ef12f4578a7b75a2573d9dba8-026332b2-2d50-452f-ad0d-50f921c97a9d-7145';
// Environment variable to override the default setup string
const ENV_SETUP_OVERRIDE = 'RNW_TELEMETRY_SETUP';
// Environment variable to override the http proxy (such as http://localhost:8888 for Fiddler debugging)
const ENV_PROXY_OVERRIDE = 'RNW_TELEMETRY_PROXY';
exports.CommandEventName = 'RNWCLI.Command';
exports.CodedErrorEventName = 'RNWCLI.CodedError';
// These are the event names we're tracking
exports.EventNamesWeTrack = [
    exports.CommandEventName,
    exports.CodedErrorEventName,
];
// These are NPM packages we care about, in terms of capturing versions used
// and getting more details about when reporting errors
exports.NpmPackagesWeTrack = [
    '@react-native-community/cli',
    '@react-native-windows/cli',
    '@react-native-windows/telemetry',
    'react',
    'react-native',
    'react-native-windows',
    'react-native-windows-init',
];
// These are NPM packages we care about, in terms of capturing versions used
exports.NuGetPackagesWeTrack = [
    'Microsoft.UI.Xaml',
    'Microsoft.Windows.CppWinRT',
    'Microsoft.WinUI',
];
/**
 * The Telemetry class is responsible for reporting telemetry for RNW CLI.
 */
class Telemetry {
    static getDefaultSetupString() {
        var _a;
        // Enable overriding the default setup string via an environment variable
        return (_a = process.env[ENV_SETUP_OVERRIDE]) !== null && _a !== void 0 ? _a : RNW_1DS_INSTRUMENTATION_KEY;
    }
    static reset() {
        // Reset client
        if (Telemetry.appInsightsCore) {
            Telemetry.appInsightsCore.flush();
            Telemetry.appInsightsCore = undefined;
        }
        // Reset local members
        Telemetry.options = {
            setupString: Telemetry.getDefaultSetupString(),
            preserveErrorMessages: false,
            populateNpmPackageVersions: true,
        };
        Telemetry.commandInfo = {};
        Telemetry.versionsProp = {};
        Telemetry.projectProp = undefined;
    }
    static isEnabled() {
        return Telemetry.appInsightsCore !== undefined;
    }
    static getSessionId() {
        return basePropUtils.getSessionId();
    }
    /** Sets up the Telemetry static to be used elsewhere. */
    static async setup(options) {
        if (Telemetry.appInsightsCore) {
            // Bail since we've already setup
            return;
        }
        // Bail if we're in CI and not capturing CI
        if (!Telemetry.isTestEnvironment &&
            basePropUtils.isCI() &&
            !basePropUtils.captureCI()) {
            return;
        }
        // Save off options for later
        Object.assign(Telemetry.options, options);
        Telemetry.setupClient();
        await Telemetry.setupBaseProperties();
    }
    static basicTelemetryInitializer(envelope) {
        // Filter out "legacy" events from older stable branches
        if (envelope.name && exports.EventNamesWeTrack.includes(envelope.name)) {
            return true;
        }
        return false;
    }
    /** Sets up Telemetry.appInsightsCore. */
    static setupClient() {
        const postChannel = new _1ds_post_js_1.PostChannel();
        const coreConfiguration = {
            instrumentationKey: Telemetry.getDefaultSetupString(),
        };
        const postChannelConfig = {
            eventsLimitInMem: 5000,
        };
        coreConfiguration.extensionConfig = {};
        coreConfiguration.extensionConfig[postChannel.identifier] =
            postChannelConfig;
        // Allow overriding the endpoint URL via an environment variable.
        if (process.env[ENV_PROXY_OVERRIDE] !== undefined) {
            coreConfiguration.endpointUrl = process.env[ENV_PROXY_OVERRIDE];
        }
        Telemetry.appInsightsCore = new coreOneDS.AppInsightsCore();
        Telemetry.appInsightsCore.initialize(coreConfiguration, [postChannel] /* extensions */);
        Telemetry.appInsightsCore.addTelemetryInitializer(Telemetry.basicTelemetryInitializer);
    }
    /** Sets up any base properties that all telemetry events require. */
    static async setupBaseProperties() {
        Telemetry.commonProperties.deviceId = await basePropUtils.deviceId();
        Telemetry.commonProperties.fullBuildInfo =
            await basePropUtils.fullBuildInfo();
        Telemetry.commonProperties.deviceArchitecture =
            basePropUtils.deviceArchitecture();
        Telemetry.commonProperties.nodeArchitecture =
            basePropUtils.nodeArchitecture();
        Telemetry.commonProperties.nodePlatform = basePropUtils.nodePlatform();
        Telemetry.commonProperties.deviceClass = basePropUtils.deviceClass();
        Telemetry.commonProperties.deviceLocale =
            await basePropUtils.deviceLocale();
        Telemetry.commonProperties.deviceNumCPUs = basePropUtils
            .deviceNumCPUs()
            .toString();
        Telemetry.commonProperties.deviceTotalMemory = basePropUtils
            .deviceTotalMemory()
            .toString();
        Telemetry.commonProperties.deviceDiskFreeSpace = basePropUtils
            .deviceDiskFreeSpace()
            .toString();
        Telemetry.commonProperties.ciCaptured = basePropUtils
            .captureCI()
            .toString();
        Telemetry.commonProperties.ciType = basePropUtils.ciType();
        Telemetry.commonProperties.isMsftInternal = basePropUtils
            .isMsftInternal()
            .toString();
        Telemetry.commonProperties.isTest = Telemetry.isTestEnvironment.toString();
        Telemetry.commonProperties.sessionId = Telemetry.getSessionId();
        await Telemetry.populateToolsVersions();
        if (Telemetry.options.populateNpmPackageVersions) {
            await Telemetry.populateNpmPackageVersions();
        }
    }
    /** Tries to update the version of the named package/tool by calling getValue(). */
    static async tryUpdateVersionsProp(name, getValue, forceRefresh) {
        if (!Telemetry.appInsightsCore) {
            return true;
        }
        // Process the package name to comply with the backend requirements
        const packageName = nameUtils.isValidTelemetryPackageName(name)
            ? name
            : nameUtils.cleanTelemetryPackageName(name);
        if (forceRefresh === true || !Telemetry.versionsProp[packageName]) {
            const value = await getValue();
            if (value) {
                Telemetry.versionsProp[packageName] = value;
                return true;
            }
        }
        return false;
    }
    /** Populates the versions property of tools we care to track. */
    static async populateToolsVersions(refresh) {
        await Telemetry.tryUpdateVersionsProp('node', versionUtils.getNodeVersion, refresh);
        await Telemetry.tryUpdateVersionsProp('npm', versionUtils.getNpmVersion, refresh);
        await Telemetry.tryUpdateVersionsProp('yarn', versionUtils.getYarnVersion, refresh);
        await Telemetry.tryUpdateVersionsProp('VisualStudio', versionUtils.getVisualStudioVersion, refresh);
    }
    /** Populates the versions property of npm packages we care to track. */
    static async populateNpmPackageVersions(refresh) {
        for (const npmPackage of exports.NpmPackagesWeTrack) {
            await Telemetry.tryUpdateVersionsProp(npmPackage, async () => await versionUtils.getVersionOfNpmPackage(npmPackage), refresh);
        }
    }
    /** Populates the versions property of nuget packages we care to track. */
    static async populateNuGetPackageVersions(projectFile, refresh) {
        const nugetVersions = await versionUtils.getVersionsOfNuGetPackages(projectFile, exports.NuGetPackagesWeTrack);
        for (const nugetPackage of exports.NuGetPackagesWeTrack) {
            await Telemetry.tryUpdateVersionsProp(nugetPackage, async () => nugetVersions[nugetPackage], refresh);
        }
    }
    static setProjectInfo(info) {
        if (!Telemetry.appInsightsCore) {
            return;
        }
        Telemetry.projectProp = info;
    }
    static startCommand(info) {
        if (!Telemetry.appInsightsCore) {
            return;
        }
        // startCommand() was called before invoking endCommand(), bail out.
        if (Telemetry.commandInfo.startInfo) {
            return;
        }
        Telemetry.commandInfo.startTime = Date.now();
        Telemetry.commandInfo.startInfo = info;
        // Set common command props
        Telemetry.commonProperties.commandName = info.commandName;
    }
    static endCommand(info, extraProps) {
        if (!Telemetry.appInsightsCore) {
            return;
        }
        // startCommand() wasn't called, bail out.
        if (!Telemetry.commandInfo.startInfo) {
            return;
        }
        Telemetry.commandInfo.endTime = Date.now();
        Telemetry.commandInfo.endInfo = info;
        Telemetry.trackCommandEvent(extraProps);
    }
    static trackEvent(telemetryItem) {
        // Populate Part A
        telemetryItem.ver = '4.0'; // Current Common Schema version
        telemetryItem.time = new Date().toISOString();
        telemetryItem.iKey = RNW_1DS_INSTRUMENTATION_KEY;
        // Populate Part A extensions
        telemetryItem.ext = {};
        telemetryItem.ext.device = {
            id: Telemetry.commonProperties.deviceId,
            deviceClass: Telemetry.commonProperties.deviceClass,
        };
        telemetryItem.ext.os = {
            locale: Telemetry.commonProperties.deviceLocale,
            ver: Telemetry.commonProperties.fullBuildInfo,
        };
        // Populate most of "common" properties into Part B.
        telemetryItem.baseData = {
            common: {
                device: {
                    architecture: Telemetry.commonProperties.deviceArchitecture,
                    numCPUs: Telemetry.commonProperties.numCPUs,
                    totalMemory: Telemetry.commonProperties.totalMemory,
                    diskFreeSpace: Telemetry.commonProperties.deviceDiskFreeSpace,
                },
                nodePlatform: Telemetry.commonProperties.nodePlatform,
                nodeArchitecture: Telemetry.commonProperties.nodeArchitecture,
                ciCaptured: Telemetry.commonProperties.ciCaptured,
                ciType: Telemetry.commonProperties.ciType,
                isMsftInternal: Telemetry.commonProperties.isMsftInternal,
                isCliTest: Telemetry.commonProperties.isTest,
                sessionId: Telemetry.commonProperties.sessionId,
                commandName: Telemetry.commonProperties.commandName,
            },
            // Set project and versions props, belonging to Part B.
            project: Telemetry.projectProp,
            versions: Telemetry.versionsProp,
        };
        // Send and post the telemetry event!
        Telemetry.appInsightsCore.track(telemetryItem);
        Telemetry.appInsightsCore.flush();
    }
    static trackCommandEvent(extraProps) {
        var _a, _b, _c, _d;
        const telemetryItem = { name: exports.CommandEventName };
        // This is logged in Part C.
        const command = {
            options: (_a = Telemetry.commandInfo.startInfo) === null || _a === void 0 ? void 0 : _a.options,
            defaultOptions: (_b = Telemetry.commandInfo.startInfo) === null || _b === void 0 ? void 0 : _b.defaultOptions,
            args: (_c = Telemetry.commandInfo.startInfo) === null || _c === void 0 ? void 0 : _c.args,
            durationInSecs: (Telemetry.commandInfo.endTime - Telemetry.commandInfo.startTime) /
                1000,
            resultCode: (_d = Telemetry.commandInfo.endInfo) === null || _d === void 0 ? void 0 : _d.resultCode,
        };
        telemetryItem.data = {
            command: command,
        };
        if (extraProps) {
            telemetryItem.data.additionalData = extraProps;
        }
        // Populate common properties and fire event
        Telemetry.trackEvent(telemetryItem);
    }
    static trackException(error, extraProps) {
        var _a, _b;
        if (!Telemetry.appInsightsCore) {
            return;
        }
        const telemetryItem = { name: exports.CodedErrorEventName };
        // Save off CodedError info in Part C.
        const codedError = error instanceof errorUtils.CodedError
            ? error
            : null;
        const codedErrorStruct = {
            type: (_a = codedError === null || codedError === void 0 ? void 0 : codedError.type) !== null && _a !== void 0 ? _a : 'Unknown',
            data: (_b = codedError === null || codedError === void 0 ? void 0 : codedError.data) !== null && _b !== void 0 ? _b : {},
        };
        // Copy msBuildErrorMessages into the codedError.data object
        if (error.msBuildErrorMessages) {
            // Always grab MSBuild error codes if possible
            codedErrorStruct.data.msBuildErrors = error.msBuildErrorMessages
                .map(errorUtils.tryGetErrorCode)
                .filter((msg) => msg);
            // Grab sanitized MSBuild error messages if we're preserving them
            if (Telemetry.options.preserveErrorMessages) {
                codedErrorStruct.data.msBuildErrorMessages = error.msBuildErrorMessages
                    .map(errorUtils.sanitizeErrorMessage)
                    .filter((msg) => msg);
            }
        }
        // Copy miscellaneous system error fields into the codedError.data object
        const syscallExceptionFieldsToCopy = ['errno', 'syscall', 'code'];
        for (const f of syscallExceptionFieldsToCopy) {
            if (error[f]) {
                codedErrorStruct.data[f] = error[f];
            }
        }
        // Scrub any potential PII present in codedError.data array, as long as the data is a string.
        codedErrorStruct.data = Telemetry.sanitizeAny(codedErrorStruct.data);
        // Break down TS Error object into Exception Data
        const exceptionData = Telemetry.convertErrorIntoExceptionData(error);
        telemetryItem.data = {
            codedError: codedErrorStruct,
            exceptionData: exceptionData,
        };
        Telemetry.trackEvent(telemetryItem);
    }
    static convertErrorIntoExceptionData(error) {
        var _a;
        const exceptionData = {
            hasFullStack: false,
            message: error.message,
            parsedStack: {},
        };
        exceptionData.message = exceptionData.message || '[None]';
        // CodedError has non-PII information in its 'type' member, plus optionally some more info in its 'data'.
        // The message may contain PII information. This can be sanitized, but for now delete it.
        if (Telemetry.options.preserveErrorMessages) {
            exceptionData.message = errorUtils.sanitizeErrorMessage(exceptionData.message);
        }
        else {
            exceptionData.message = '[Removed]';
        }
        const lines = (_a = error.stack) === null || _a === void 0 ? void 0 : _a.split('\n');
        const parsedStack = lines === null || lines === void 0 ? void 0 : lines.slice(1).map(line => {
            const errorStackFrame = {};
            const match = line
                .trim()
                .match(/^\s*at\s+(?:(.*?)\s+\((.*):(\d+):(\d+)\)|(.*):(\d+):(\d+))$/);
            if (match) {
                errorStackFrame.functionName = match[1] || 'N/A'; // Use a default value if no function name
                errorStackFrame.filePath = match[2] || match[5];
                errorStackFrame.lineNumber =
                    parseInt(match[3], 10) || parseInt(match[6], 10);
                errorStackFrame.columnNumber =
                    parseInt(match[4], 10) || parseInt(match[7], 10);
            }
            return errorStackFrame;
        });
        if (parsedStack) {
            parsedStack.filter(Boolean);
            // Sanitize parsed error stack frames
            for (const frame of parsedStack) {
                errorUtils.sanitizeErrorStackFrame(frame);
            }
            exceptionData.hasFullStack = true;
            exceptionData.parsedStack = parsedStack;
        }
        return exceptionData;
    }
    static sanitizeAny(data) {
        if (Array.isArray(data)) {
            // This is an array, sanitize each element recursively.
            return data.map(item => Telemetry.sanitizeAny(item));
        }
        else if (typeof data === 'object' && data !== null) {
            // This is an object, sanitize each field recursively.
            const sanitizedObject = {};
            for (const key in data) {
                if (Object.prototype.hasOwnProperty.call(data, key)) {
                    sanitizedObject[key] = Telemetry.sanitizeAny(data[key]);
                }
            }
            return sanitizedObject;
        }
        else if (typeof data === 'string') {
            // The base case: this is a string, sanitize it.
            return errorUtils.sanitizeErrorMessage(data);
        }
        // Not a string, return the data unchanged.
        return data;
    }
}
Telemetry.appInsightsCore = undefined;
Telemetry.options = {
    setupString: Telemetry.getDefaultSetupString(),
    preserveErrorMessages: false,
    populateNpmPackageVersions: true,
};
Telemetry.isTestEnvironment = basePropUtils.isCliTest();
Telemetry.commandInfo = {};
// Stores the version of a list of packages used by the RNW app project.
Telemetry.versionsProp = {};
Telemetry.projectProp = undefined;
// Store "Common Properties" in a single object. This will be logged in all telemetry events.
Telemetry.commonProperties = {};
exports.Telemetry = Telemetry;
//# sourceMappingURL=telemetry.js.map